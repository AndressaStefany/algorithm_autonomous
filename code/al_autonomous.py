# -*- coding: utf-8 -*-
"""al_autonomous.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zf4Lf8EZPzRV1wEgyYhXXaBAm_M3hp1d

# Boot
"""

from update_clusters_euc import update_winner_cluster_euc, update_nearest_cluster_euc
from new_cluster_euc import new_cluster_euc
from utils_euc import get_cluster_min_dist_euc
from split import split
from volume import get_volume
from radius import get_radius
from merge import merge
from overlap import overlap
from update_clusters import update_winner_cluster, update_nearest_cluster
from new_cluster_range import new_cluster
from utils import get_cluster_min_dist
from sklearn.utils import shuffle
import random
from tqdm import tqdm
from scipy.spatial import distance
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from google.colab import drive
drive.mount("/gdrive", force_remount=True)

!cp - r '/gdrive/My Drive/Mestrado/07 - Autonomous/code/' '/content'
!mv '/content/code' '/content/scripts'
!cp '/content/scripts/cluster.py' '/content'
!cp '/content/scripts/radius.py' '/content'
!cp '/content/scripts/new_cluster.py' '/content'
!cp '/content/scripts/update_clusters.py' '/content'
!cp '/content/scripts/utils.py' '/content'
!cp '/content/scripts/new_cluster_euc.py' '/content'
!cp '/content/scripts/new_cluster_range.py' '/content'
!cp '/content/scripts/update_clusters_euc.py' '/content'
!cp '/content/scripts/utils_euc.py' '/content'
!cp '/content/scripts/overlap.py' '/content'
!cp '/content/scripts/merge.py' '/content'
!cp '/content/scripts/volume.py' '/content'
!cp '/content/scripts/split.py' '/content'
!rm - r '/content/scripts/'

!cp - r '/gdrive/My Drive/Mestrado/07 - Autonomous/data/' '/content'


# to see whatâ€™s spending the most time
# python3 -m cProfile -s cumtime al_autonomous.py > a1.txt

"""# Colors"""

# random list of colors

list_cor = []
for i in range(0, 10000):
    def r(): return random.randint(0, 255)
    cor = '#%02X%02X%02X' % (r(), r(), r())
    list_cor.append(cor)

unique_list = np.array(list_cor)
unique_list = np.unique(unique_list)
print(len(unique_list))
print(len(list_cor))
list_cor = unique_list

list_cor = shuffle(list_cor)

barWidth = 1

plt.figure(figsize=(10, 5))
for i in range(0, len(list_cor)):
    plt.bar(i, 10, color=list_cor[i], width=barWidth, label=str(list_cor[i]))
plt.show()

alist = ['green', 'red', 'black', 'blue', 'gray', 'orange', 'violet', 'pink',
         'brown', 'yellow', '#c2945d',
         '#DEB887', '#5F9EA0', '#D2691E',  '#fa926b', '#5bc95b']

"""# Algorithm

## The first
"""


# whitout split

class Autonomous:
    def __init__(self, range_, fac, frac=100, m=4):  # default of article
        self.range_ = range_
        self.fac = fac
        self.frac = frac
        self.m = m
        self.clusters = []

    pass

    # input x = np.array
    def process(self, x):
        p = len(x)

        # the first cluster
        if len(self.clusters) == 0:
            self.clusters.append(new_cluster(
                x, self.frac, self.fac, p, self.m, self.range_))

        else:
            # elect winning cluster
            win_cluster = get_cluster_min_dist(x, self.clusters)
            win_cluster_radius = get_radius(
                self.fac, p, self.m, win_cluster.k)

            # point is not contained in the winning cluster
            if (distance.mahalanobis(x, win_cluster.centroid, win_cluster.inv_cov) > win_cluster_radius):
                self.clusters.append(new_cluster(
                    x, self.frac, self.fac, p, self.m, self.range_))

            else:
                self.clusters.remove(win_cluster)
                # update winning cluster
                update_winner_cluster(x, win_cluster)

                if len(self.clusters) != 0:
                    # update nearest neighbor of winning cluster
                    update_nearest_cluster(x, win_cluster, self.clusters)

                # check overlap
                (max_olap, max_cluster) = overlap(
                    win_cluster, self.clusters)

                if (max_olap > 0):
                    cluster_merged = merge(win_cluster, max_cluster)

                    V_m = get_volume(cluster_merged, self.fac, p, self.m)
                    V_w = get_volume(win_cluster, self.fac, p, self.m)
                    V_c = get_volume(max_cluster, self.fac, p, self.m)

                    # Check volume, for the final decision
                    if V_m <= p*(V_w + V_c):
                        self.clusters.remove(max_cluster)
                        self.clusters.append(cluster_merged)
                    else:
                        self.clusters.append(win_cluster)
                # split(self.clusters, win_cluster)
                else:
                    self.clusters.append(win_cluster)

        pass


"""## With Euclidean distance"""


class Autonomous_euc:
    def __init__(self, fac, frac=100, m=4):  # default of article
        self.fac = fac
        self.frac = frac
        self.m = m
        self.clusters = []

    pass

    # input x = np.array
    def process(self, x):
        p = len(x)

        # the first cluster
        if len(self.clusters) == 0:
            self.clusters.append(new_cluster_euc(
                x, self.frac, self.fac, p, self.m))

        else:
            # elect winning cluster
            win_cluster = get_cluster_min_dist_euc(x, self.clusters)
            win_cluster_radius = get_radius(
                self.fac, p, self.m, win_cluster.k)

            if (np.sqrt(((x - win_cluster.centroid) ** 2).sum()) > win_cluster_radius):
                self.clusters.append(new_cluster_euc(
                    x, self.frac, self.fac, p, self.m))

            else:
                self.clusters.remove(win_cluster)
                # update winning cluster
                update_winner_cluster_euc(x, win_cluster)

                if len(self.clusters) != 0:
                    # update nearest neighbor of winning cluster
                    update_nearest_cluster_euc(x, win_cluster, self.clusters)
                # self.clusters.append(win_cluster)
                split(self.clusters, win_cluster)

        pass


"""# Test with S1

http://cs.joensuu.fi/sipu/datasets/

## Data
"""

data_s1 = pd.read_csv('data/s1.txt', delimiter='    ',
                      header=None, engine='python')
print(data_s1.values)
print(type(data_s1.values))
print(len(data_s1.values))

data = data_s1
normalized_df = (data-data.min())/(data.max()-data.min())

data_s1_cb = pd.read_csv('data/s1-cb.txt', delimiter=' ',
                         header=None, engine='python')
data_s1_cb = data_s1_cb.drop([2], axis=1)
print(len(data_s1_cb.values))

"""## Teste with first algoritm"""

x = np.var(data_s1[0])
y = np.var(data_s1[1])
range_ = np.array([x, y])

autonomous_S1 = Autonomous(range_=range_, fac=20.0)
for r in tqdm(data_s1.values):
    autonomous_S1.process(r)
print('\n')
print('numero de clusters: ', len(autonomous_S1.clusters))

"""## Test with Euclidian"""

autonomous_S1_1 = Autonomous_euc(fac=0.16)  # 0.1
for r in tqdm(normalized_df.values):
    autonomous_S1_1.process(r)
print('\n')
print('numero de clusters: ', len(autonomous_S1_1.clusters))

i = 0
plt.figure()
for clusters in autonomous_S1_1.clusters:
    plt.scatter(np.array(clusters.S)[:, 0],
                np.array(clusters.S)[:, 1],
                c=list_cor[i+10], s=40)
    i += 1
plt.show()
